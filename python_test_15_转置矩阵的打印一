问题：给定一个3*3方阵,求其转置矩阵
[1, 2, 3]       [1, 4, 7]
[4, 5, 6]  =>   [2, 5, 8]
[7, 8, 9]       [3, 6, 9]

转置矩阵简介：将矩阵的行列互换得到的新矩阵称为转置矩阵,转置矩阵的行列式不变

测试01：观察原矩阵和转置后的矩阵沿着对角线对齐,因此交换坐标既可以得到
lst = [[1,2,3],[4,5,6],[7,8,9]]  #原矩阵
tend = [[0]*3,[0]*3,[0]*3]  #初始化一个新的3*3矩阵
for i in range(3):
    for j in range(3):
        tend[j][i] = lst[i][j]  #交换坐标
else:
    print("原矩阵：",lst)
print("新矩阵：",tend)

原矩阵： [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
新矩阵： [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

测试02：对上一个使用封装和解构
lst = [[1,2,3],[4,5,6],[7,8,9]]  #原矩阵
print("原矩阵：",lst)
for i in range(3):
    for j in range(i,3):  #第一次转置完之后最外层已经完整,下面只需要内部转置即可
        lst[j][i],lst[i][j] = lst[i][j],lst[j][i]  #最外层的值交换坐标
else:
    print("新矩阵：",lst)

原矩阵： [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
新矩阵： [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

测试03：减少重复的交换
lst = [[1,2,3],[4,5,6],[7,8,9]]  #原矩阵
print("原矩阵：",lst)
count = 0
for i in range(3):
    for j in range(i):  #减少重复交换
        lst[j][i],lst[i][j] = lst[i][j],lst[j][i]  #交换坐标
        count = count + 1
else:
    print("新矩阵：",lst)
print("count：",count)

原矩阵： [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
新矩阵： [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
count： 3
